import {
  require_react_dom
} from "./chunk-OK4P3QOP.js";
import {
  __commonJS,
  __toESM,
  require_react
} from "./chunk-5A2KPB3J.js";

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports) {
    "use strict";
    var m = require_react_dom();
    if (false) {
      exports.createRoot = m.createRoot;
      exports.hydrateRoot = m.hydrateRoot;
    } else {
      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      exports.createRoot = function(c, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.createRoot(c, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
      exports.hydrateRoot = function(c, h, o) {
        i.usingClientEntryPoint = true;
        try {
          return m.hydrateRoot(c, h, o);
        } finally {
          i.usingClientEntryPoint = false;
        }
      };
    }
    var i;
  }
});

// node_modules/cypress/react/dist/cypress-react.esm-bundler.js
var React = __toESM(require_react());
var import_client = __toESM(require_client());
function getDisplayName(node, fallbackName = "Unknown") {
  const type = node === null || node === void 0 ? void 0 : node.type;
  if (!type) {
    return fallbackName;
  }
  let displayName = null;
  if (typeof type.displayName === "string") {
    displayName = type.displayName;
  }
  if (!displayName) {
    displayName = type.name || fallbackName;
  }
  const match = displayName.match(/^(.*) \[from (.*)\]$/);
  if (match) {
    const componentName = match[1];
    const moduleName = match[2];
    if (componentName && moduleName) {
      if (moduleName === componentName || moduleName.startsWith(`${componentName}.`)) {
        displayName = componentName;
      }
    }
  }
  return displayName;
}
var ROOT_SELECTOR = "[data-cy-root]";
var getContainerEl = () => {
  const el = document.querySelector(ROOT_SELECTOR);
  if (el) {
    return el;
  }
  throw Error(`No element found that matches selector ${ROOT_SELECTOR}. Please add a root element with data-cy-root attribute to your "component-index.html" file so that Cypress can attach your component to the DOM.`);
};
function setupHooks(optionalCallback) {
  if (Cypress.testingType !== "component") {
    return;
  }
  Cypress.Commands.overwrite("visit", () => {
    throw new Error("cy.visit from a component spec is not allowed");
  });
  Cypress.Commands.overwrite("session", () => {
    throw new Error("cy.session from a component spec is not allowed");
  });
  Cypress.Commands.overwrite("origin", () => {
    throw new Error("cy.origin from a component spec is not allowed");
  });
  Cypress.on("test:before:after:run:async", () => {
    optionalCallback === null || optionalCallback === void 0 ? void 0 : optionalCallback();
  });
}
var mountCleanup;
var makeMountFn = (type, jsx, options = {}, rerenderKey, internalMountOptions) => {
  if (!internalMountOptions) {
    throw Error("internalMountOptions must be provided with `render` and `reactDom` parameters");
  }
  mountCleanup = internalMountOptions.cleanup;
  return cy.then(() => {
    var _a, _b, _c;
    const reactDomToUse = internalMountOptions.reactDom;
    const el = getContainerEl();
    if (!el) {
      throw new Error([
        `[@cypress/react] ðŸ”¥ Hmm, cannot find root element to mount the component. Searched for ${ROOT_SELECTOR}`
      ].join(" "));
    }
    const key = rerenderKey !== null && rerenderKey !== void 0 ? rerenderKey : (
      // @ts-ignore provide unique key to the the wrapped component to make sure we are rerendering between tests
      (((_c = (_b = (_a = Cypress === null || Cypress === void 0 ? void 0 : Cypress.mocha) === null || _a === void 0 ? void 0 : _a.getRunner()) === null || _b === void 0 ? void 0 : _b.test) === null || _c === void 0 ? void 0 : _c.title) || "") + Math.random()
    );
    const props = {
      key
    };
    const reactComponent = React.createElement(options.strict ? React.StrictMode : React.Fragment, props, jsx);
    const userComponent = reactComponent.props.children;
    internalMountOptions.render(reactComponent, el, reactDomToUse);
    return cy.wrap(userComponent, { log: false }).then(() => {
      return cy.wrap({
        component: userComponent,
        rerender: (newComponent) => makeMountFn("rerender", newComponent, options, key, internalMountOptions)
      }, { log: false });
    }).wait(0, { log: false }).then(() => {
      if (options.log !== false) {
        const componentName = getDisplayName(jsx);
        const jsxComponentName = `<${componentName} ... />`;
        Cypress.log({
          name: type,
          type: "parent",
          message: [jsxComponentName],
          // @ts-ignore
          $el: el.children.item(0),
          consoleProps: () => {
            return {
              // @ts-ignore protect the use of jsx functional components use ReactNode
              props: jsx === null || jsx === void 0 ? void 0 : jsx.props,
              description: type === "mount" ? "Mounts React component" : "Rerenders mounted React component",
              home: "https://github.com/cypress-io/cypress"
            };
          }
        });
      }
    });
  });
};
var makeUnmountFn = (options) => {
  return cy.then(() => {
    var _a;
    const wasUnmounted = mountCleanup === null || mountCleanup === void 0 ? void 0 : mountCleanup();
    if (wasUnmounted && options.log) {
      Cypress.log({
        name: "unmount",
        type: "parent",
        message: [(_a = options.boundComponentMessage) !== null && _a !== void 0 ? _a : "Unmounted component"],
        consoleProps: () => {
          return {
            description: "Unmounts React component",
            parent: getContainerEl().parentNode,
            home: "https://github.com/cypress-io/cypress"
          };
        }
      });
    }
  });
};
var preMountCleanup = () => {
  mountCleanup === null || mountCleanup === void 0 ? void 0 : mountCleanup();
};
var _mount = (jsx, options = {}) => makeMountFn("mount", jsx, options);
var createMount = (defaultOptions) => {
  return (element, options) => {
    return _mount(element, Object.assign(Object.assign({}, defaultOptions), options));
  };
};
setupHooks(preMountCleanup);
var root;
var cleanup = () => {
  if (root) {
    root.unmount();
    root = null;
    return true;
  }
  return false;
};
function mount(jsx, options = {}, rerenderKey) {
  cleanup();
  const internalOptions = {
    reactDom: import_client.default,
    render: (reactComponent, el) => {
      if (!root) {
        root = import_client.default.createRoot(el);
      }
      return root.render(reactComponent);
    },
    unmount: internalUnmount,
    cleanup
  };
  return makeMountFn("mount", jsx, Object.assign({ ReactDom: import_client.default }, options), rerenderKey, internalOptions);
}
function internalUnmount(options = { log: true }) {
  return makeUnmountFn(options);
}
export {
  createMount,
  getContainerEl,
  makeMountFn,
  makeUnmountFn,
  mount
};
//# sourceMappingURL=cypress_react.js.map
